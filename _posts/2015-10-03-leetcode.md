---
layout: post
title: LeetCode
tag: leetcode, python, algorithm
---

{{ page.title }}
=================

## 部分leetcode 题解

1. Merge k Sorted Lists  
合并k个有序的链表为一个有序链表。  

__思路__:
每次取k个链表头中最小的加入新的链表，直达k个链表都为空结束。
不过如果每次循环查找k个链表头最小的需要O(k)时间复杂度，整个
程序的时间复杂度为O(kn)，将会TLE。  

__优化方法__: 维护一个含k个值的优先队列，每次取出最小值添加的链表
中，然后把最小值所在的链表的头的值放入优先队列中，直到优先队列
为空。 [完整代码](https://github.com/qianlv/learning/blob/master/leetcode/merge_k_sorted_link.py),  
核心代码:  

    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        res = ListNode(-1)
        tmp = res

        priority_queue = []
        for i, node in enumerate(lists):
            if node is None:
                continue
            heappush(priority_queue, (node.val, i))
            lists[i] = node.next

        while True:
            try:
                val, i = heappop(priority_queue)
            except IndexError:
                break

            tmp.next = ListNode(val)
            tmp = tmp.next

            node = lists[i]
            if node is not None:
                heappush(priority_queue, (node.val, i))
                lists[i] = node.next
        return res.next

